import { ColumnDef } from '@tanstack/react-table';
import type { ProductsAPIInput, ProductsAPIOutput } from './api/products';
import { CustomGetNextPageParam, useDebounce } from '@/utils/hooks';

import Head from 'next/head';
import { Inter } from '@next/font/google';
import styles from '@/styles/Home.module.css';
import { memo, useId, useMemo } from 'react';
import { useCustomInfiniteQuery } from '@/utils/hooks';
import { Products } from '@/ts';
import {
	createColumnHelper,
	flexRender,
	getCoreRowModel,
	useReactTable
} from '@tanstack/react-table';

const inter = Inter({ subsets: ['latin'] });

const fetchProducts = async (query: {
	limit: 5 | 10 | 20;
	offset: number;
}): Promise<ProductsAPIOutput> => {
	return await fetch(
		`/api/products/?limit=${query.limit}&offset=${query.offset}`
	).then((response) => {
		if (response.status === 404) throw new Error('Not Found');
		if (response.status === 400) throw new Error('Bad Request');

		return response.json();
	});
};

const defaultCursor: {
	offset: ProductsAPIInput['offset'];
	limit: ProductsAPIInput['limit'];
} = {
	limit: 5,
	offset: 0
};

const columnHelper = createColumnHelper<Products>();
const columns = [
	columnHelper.accessor('id', {
		cell: (info) => info.getValue(),
		// header: info => info
		footer: (info) => info.column.id
	}),
	columnHelper.accessor('title', {
		cell: (info) => info.getValue(),
		// header: info => info
		footer: (info) => info.column.id
	}),
	columnHelper.accessor('description', {
		cell: (info) => info.getValue(),
		// header: info => info
		footer: (info) => info.column.id
	}),
	columnHelper.accessor('price', {
		cell: (info) => info.getValue(),
		// header: info => info
		footer: (info) => info.column.id
	})
];

const getNextPageParam: CustomGetNextPageParam<
	ProductsAPIOutput,
	ProductsAPIInput
> = (lastPage, allPages) => {
	if (lastPage?.cursor) {
		if (lastPage.data.products.length < lastPage.cursor.limit) return undefined;

		return {
			...lastPage.cursor,
			offset: lastPage.cursor.offset + lastPage.cursor.limit
		};
	}

	return defaultCursor;
};

type FilterBy = NonNullable<ProductsAPIInput['filterBy']>;
export default function Home() {
	const id = useId();
	const {
		value: filterByFormValues,
		debouncedValue: filterByFormValuesDebounced,
		setValue: setFilterByFormValues
	} = useDebounce<FilterBy>(
		{
			category: undefined,
			priceGTE: undefined,
			title: undefined
		},
		300
	);

	const formFields: {
		name: keyof FilterBy;
		value: FilterBy[keyof FilterBy];
		type?: 'number';
	}[] = [
		{ name: 'category', value: undefined },
		{ name: 'priceGTE', value: undefined, type: 'number' },
		{ name: 'title', value: undefined }
	];

	const {
		infiniteQuery,
		infiniteQueryData,
		isNextPageDisabled,
		isPreviousPageDisabled,
		currentIndex,
		setCurrentIndex
	} = useCustomInfiniteQuery<
		ProductsAPIOutput,
		['products', { cursor: typeof defaultCursor; filterBy?: FilterBy }]
	>({
		defaultCursor,
		queryMainKey: 'products',
		fetchFn: async (query): Promise<ProductsAPIOutput> => {
			console.log('query.filterBy', query.filterBy);
			return await fetch(
				`/api/products/?limit=${query.cursor.limit}&offset=${
					query.cursor.offset
				}${
					query.filterBy && Object.keys(query.filterBy).length !== 0
						? `&filterBy=${decodeURIComponent(JSON.stringify(query.filterBy))}`
						: ''
				}`
			).then((response) => {
				if (response.status === 404) throw new Error('Not Found');
				if (response.status === 400) throw new Error('Bad Request');

				return response.json();
			});
		},
		getNextPageParam: (lastPage, allPages) => {
			if (lastPage?.cursor) {
				if (lastPage.data.products.length < lastPage.cursor.limit)
					return undefined;

				return {
					...lastPage.cursor,
					offset: lastPage.cursor.offset + lastPage.cursor.limit
				};
			}

			return defaultCursor;
		},
		filterBy: filterByFormValuesDebounced
	});
	const pages = infiniteQueryData.pages || [];
	const currentPage = useMemo(
		() => infiniteQuery.data?.pages?.[currentIndex]?.data.products || [],
		[currentIndex, infiniteQuery.data?.pages]
	);

	const data = useMemo(
		() => [
			{ id: 1, taskName: 'Task 1', type: 'Task', dueDate: '28/08/2020' },
			{ id: 2, taskName: 'Task 2', type: 'Task', dueDate: '28/09/2020' },
			{
				id: 3,
				taskName: 'Task 3',
				type: 'Information Request',
				dueDate: '28/10/2020'
			}
		],
		[]
	);

	return (
		<>
			<Head>
				<title>Create Next App</title>
				<meta name='description' content='Generated by create next app' />
				<meta name='viewport' content='width=device-width, initial-scale=1' />
				<link rel='icon' href='/favicon.ico' />
			</Head>
			<main className={`${styles.main} max-w-full`}>
				<div>
					<form className='flex flex-col gap-2'>
						{formFields.map((field) => (
							<div key={field.name} className='flex flex-wrap gap-2'>
								<label htmlFor={`${field.name}-${id}`} className='capitalize'>
									{field.name}
								</label>
								<input
									id={`${field.name}-${id}`}
									{...field}
									value={filterByFormValues[field.name] || ''}
									onChange={(event) =>
										setFilterByFormValues((prevData) => ({
											...prevData,
											[field.name]: !event.target.value
												? undefined
												: field.type === 'number'
												? event.target.valueAsNumber
												: event.target.value
										}))
									}
								/>
								<button
									type='button'
									onClick={() =>
										setFilterByFormValues((prevData) => ({
											...prevData,
											[field.name]: undefined
										}))
									}
								>
									reset
								</button>
							</div>
						))}
					</form>
				</div>
				<div className='flex flex-col gap-2'>
					<div className='flex flex-wrap gap-2'>
						<button
							disabled={isPreviousPageDisabled}
							onClick={() =>
								!isPreviousPageDisabled &&
								setCurrentIndex((prevData) => prevData - 1)
							}
							className='disabled:grayscale disabled:cursor-not-allowed disabled:brightness-50'
						>
							Previous Page
						</button>
						<button
							disabled={isNextPageDisabled}
							onClick={() =>
								!isNextPageDisabled &&
								infiniteQuery.fetchNextPage().then((res) => {
									if (res.data && Array.isArray(res.data?.pages)) {
										const lastPage = res.data.pages[res.data.pages.length - 1];
										if (lastPage.data.products.length < 0) return;
									}

									setCurrentIndex((prevData) => prevData + 1);
								})
							}
							className='disabled:grayscale disabled:cursor-not-allowed disabled:brightness-50'
						>
							Next Page
						</button>
					</div>
					<div
						className={`${inter.className} overflow-auto max-w-full flex flex-col gap-2`}
					>
						<p>Filters: {JSON.stringify(filterByFormValues)}</p>
						<p>
							Pages:{' '}
							{JSON.stringify(
								pages.map((item) =>
									item.data.products.flat().map((product) => product.id)
								)
							)}
						</p>
						<p>Current index: {JSON.stringify(currentIndex)}</p>
						<p>
							Current Page:{' '}
							{JSON.stringify(
								currentPage.map(
									(product) => `${product.title}, ${product.price}` + '\n'
								)
							)}
						</p>
					</div>
				</div>
				<div className=''>
					{/* {!infiniteQuery.isLoading && (
						<ProductsTableMemoized
							isLoading={false}
							data={data}
							columns={columns}
						/>
					)} */}
					<ProductsTableMemoized
						isLoading={infiniteQuery.isLoading}
						data={currentPage}
						columns={columns}
					/>
				</div>
			</main>
		</>
	);
}

const ProductsTable = <TData extends Record<string, any>>({
	data,
	columns,
	isLoading
}: {
	data: TData[];
	isLoading: boolean;
	columns: ColumnDef<TData, any>[];
}) => {
	const table = useReactTable({
		data,
		columns,
		getCoreRowModel: getCoreRowModel()
	});

	return (
		<table className='table-fixed text-base text-gray-100'>
			<thead className='p-2'>
				{table.getHeaderGroups().map((headerGroup) => (
					<tr key={headerGroup.id} className='border border-green-500'>
						{headerGroup.headers.map((header) => (
							<th key={header.id} className='border border-green-500 p-2'>
								{header.isPlaceholder
									? null
									: flexRender(
											header.column.columnDef.header,
											header.getContext()
									  )}
							</th>
						))}
					</tr>
				))}
			</thead>
			<tbody>
				{table.getRowModel().rows.map((row) => (
					<tr key={row.id} className='border border-green-500'>
						{row.getVisibleCells().map((cell) => (
							<td key={cell.id} className='border border-green-500 p-5'>
								{flexRender(cell.column.columnDef.cell, cell.getContext())}
							</td>
						))}
					</tr>
				))}
			</tbody>
			<tfoot>
				{table.getFooterGroups().map((footerGroup) => (
					<tr key={footerGroup.id} className='border border-green-500'>
						{footerGroup.headers.map((header) => (
							<th key={header.id} className='border border-green-500 p-2'>
								{header.isPlaceholder
									? null
									: flexRender(
											header.column.columnDef.footer,
											header.getContext()
									  )}
							</th>
						))}
					</tr>
				))}
			</tfoot>
		</table>
	);
};

const ProductsTableMemoized = ProductsTable;

// memo(ProductsTable, (prevProps, currentProps) => {
// 	return prevProps.isLoading !== currentProps.isLoading;
// });
